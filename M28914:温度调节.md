Vlad回到家，发现有人把旧的温度调节器调到了温度a。

温度调节器只能设置为 l 到 r（包含边界）的温度，温度变化不能小于 x。如果|a - b|≥ x 且 l≤b≤r，则可以在一次操作中将温度调节器从温度 a 调节为温度 b。

已知 l, r, x, a 和 b。找出从温度 a 得到温度 b 所需的最小操作次数，或者得到不可能实现温度调节的判断。

输入
输入的第一行包含单个整数 t（1≤t≤10^4），表示测试中的测试样例的数量。

下面是测试样例的描述：

每个测试样例的第一行包含三个整数 l, r 和 x (−10^9 ≤ l≤ r ≤ 10^9, 1≤x≤10^9)，表示温度范围和最小温度变化。

每个测试样例的第二行包含两个整数 a 和 b (l≤a,b≤r)，表示初始温度和最终温度。
输出
输出 t 个数字，表示 t 个测试样例对应的答案。如果无法达到温度b，则输出-1，否则输出最小操作次数。
样例输入
10
3 5 6
3 3
0 15 5
4 5
0 10 5
3 7
3 5 6
3 4
-10 10 11
-5 6
-3 3 4
1 0
-5 10 8
9 2
1 5 1
2 5
-1 4 3
0 2
-6 3 6
-1 -4
样例输出
0
2
3
-1
1
-1
3
1
3
-1

# 在第1个测试样例中，温度调节器已经被正确设置。

在第2个测试样例中，可以按照以下方式调节温度：4→10→5

在第3个测试样例中，可以按照以下方式调节温度：3→8→2→7

在第4个测试样例中，不可能从温度a调节到温度b。
提示
greedy, math, shortest paths
```cpp
typedef long long LL;
LL l,r,x,a,b;
bool check(LL p){return l<=p&&p<=r;}
bool jump(LL a,LL b){return check(b)&&abs(a-b)>=x;} 
int mian(){
	if(a==b) return 0;
	if(jump(a,b)) return 1;//一步到位已结束
	if(jump(a,l)&&jump(l,b)) return 2;
	if(jump(a,r)&&jump(r,b)) return 2;//尝试跳到 b，贪心跳左右端点 
	if(jump(a,r)&&jump(r,l)&&jump(l,b)) return 3;
	if(jump(a,l)&&jump(l,r)&&jump(r,b)) return 3;
	return -1;
}
```
